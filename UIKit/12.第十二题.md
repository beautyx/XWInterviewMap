## 详细描述一下 UIView 与 CALayer 的关系，drawRect 一定会影响性能吗？UI Dynamics 与 UIKit Animation 的最本质区别是什么？

#### UIView 与 CALayer 的关系？
UIView 负责了与人的动作交互以及对 CALayer 的管理，CALayer 则负责了所有能让人看到的东西。

`UIView` 和 `CALayer` 算是相互补充的关系。

`UIView` = `CALayer.delegate` 

`UIView` : 继承自 `UIResponder` , 负责用户的交互事件。

`CALayer`: 继承自 `NSObject` , 负责图像和动画的渲染。

* 创建UIView对象时，UIView内部会自动创建一个层(CALayer对象)，通过UIView的layer属性可以访问这个层。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图渲染，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示

* UIView相比CALayer最大区别是UIView继承自UIResponder，可以响应用户事件，而CALayer不可以；UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。

* UIView本身，更像是一个CALayer的管理器，访问它的和绘图、坐标相关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性

* UIView和CALayer是相互依赖的关系。UIView依赖CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。

* CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)

#### drawRect 一定会影响性能吗？

软件绘图不仅效率低，还会消耗可观的内存。CALayer只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给contents属性一张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作为contents属性，那么他们将会共用同一块内存，而不是复制内存块。
    但是一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽 * 图层高 * 4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048 * 1526 * 4 字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。
    软件绘图的代价昂贵，除非绝对必要，你应该避免重绘你的视图。提高绘制性能的秘诀就在于尽量避免去绘制。
    
##### 绘图，我们可以尝试使用CAShapeLayer + UIBezierPath。

Core Graphics框架 有强大的api，但是UIBezierPath 对paths进一步封装，使用更加简单，同时我们使用CAShapeLayer 才会使UIBezierPath发挥出更大的作用。

CAShapeLayer继承自CALayer，可以使用CALayer的所有属性值。

CAShapeLayer属于CoreAnimation框架，其动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言（实现drawRect消耗性能跟CoreGraphics 这个框架是基于CPU没有关系），GPU图像处理工作更多在硬件层面，效率极高；

一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。

#### UIKit Dynamics 与 UIKit Animation 的最本质区别是什么？

Dynamics更多的是物理仿真的动画，UIKit Animation更多是线性动画