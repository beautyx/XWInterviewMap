# iOS进阶 - 如何利用 RunLoop 原理去监控卡顿

导致卡顿的几种原因：

* 复杂 UI、图文混排的绘制量过大
* 在主线程上做网络同步请求
* 在主线程上做大量 IO 操作
* 运算量过大，CPU 持续高占用
* 死锁和主子线程抢锁
 
我们可以通过监控 NSRunLoop 的状态，能够发现调用方法是否执行时间过长，从而判断是否会出现卡顿

### RunLoop 原理

RunLoop 在iOS里是有 CFRunLoop 实现，简单来说，RunLoop 是用来监听输入源，进行调度处理的。这里的输入源可以是 输入设备、网络、周期性或者延迟时间、异步回调。RunLoop 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预定时间或者重复间隔的同步事件。

RunLoop 目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，了解 RunLoop 原理不光能够运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急的会占用大量CPU的任务（比如图片加载），放到空闲的 RunLoop 模式里执行，这样就可以避开 `UITrackingRunLoopMode` 这个模式下执行了。`UITrackingRunLoopMode` 模式是用户在进行滚动时 RunLoop 的模式，避免在这个 RunLoop 模式下执行繁重的 CPU 任务就能够避免影响用户交互操作上的体验。



